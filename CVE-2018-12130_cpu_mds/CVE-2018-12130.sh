#!/bin/bash

# Copyright (c) 2019  Red Hat, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

VERSION="1.2"

# Warning! Be sure to download the latest version of this script from its primary source:

ARTICLE="https://access.redhat.com/security/vulnerabilities/mds"

# DO NOT blindly trust any internet sources and NEVER do `curl something | bash`!

# This script is meant for simple detection of the vulnerability. Feel free to modify it for your
# environment or needs. For more advanced detection, consider Red Hat Insights:
# https://access.redhat.com/products/red-hat-insights#getstarted

# Checking against the list of vulnerable packages is necessary because of the way how features
# are back-ported to older versions of packages in various channels.


basic_args() {
    # Parses basic commandline arguments and sets basic environment.
    #
    # Args:
    #     parameters - an array of commandline arguments
    #
    # Side effects:
    #     Exits if --help parameters is used
    #     Sets COLOR constants and debug variable

    local parameters=( "$@" )

    RED="\\033[1;31m"
    YELLOW="\\033[1;33m"
    GREEN="\\033[1;32m"
    BOLD="\\033[1m"
    RESET="\\033[0m"
    for parameter in "${parameters[@]}"; do
        if [[ "$parameter" == "-h" || "$parameter" == "--help" ]]; then
            echo "Usage: $( basename "$0" ) [-n | --no-colors] [-d | --debug]"
            exit 1
        elif [[ "$parameter" == "-n" || "$parameter" == "--no-colors" ]]; then
            RED=""
            YELLOW=""
            GREEN=""
            BOLD=""
            RESET=""
        elif [[ "$parameter" == "-d" || "$parameter" == "--debug" ]]; then
            debug=true
        fi
    done
}


basic_reqs() {
    # Prints common disclaimer and checks basic requirements.
    #
    # Args:
    #     CVE - string printed in the disclaimer
    #
    # Side effects:
    #     Exits when 'rpm' command is not available

    local CVE="$1"

    # Disclaimer
    echo
    echo -e "${BOLD}This script (v$VERSION) is primarily designed to detect"
    echo -e "$CVE"
    echo -e "on supported Red Hat Enterprise Linux systems and kernel packages."
    echo -e "Result may be inaccurate for other RPM based systems.${RESET}"
    echo

    # RPM is required
    if ! command -v rpm &> /dev/null; then
        echo "'rpm' command is required, but not installed. Exiting."
        exit 1
    fi
}


check_supported_kernel() {
    # Checks if running kernel is supported.
    #
    # Args:
    #     running_kernel - kernel string as returned by 'uname -r'
    #
    # Side effects:
    #     Exits when running kernel is obviously not supported

    local running_kernel="$1"

    # Check supported platform
    if [[ "$running_kernel" != *".el"[5-8]* ]]; then
        echo -e "${RED}This script is meant to be used only on RHEL 5-8.${RESET}"
        exit 1
    fi
}


get_rhel() {
    # Gets RHEL number.
    #
    # Args:
    #     running_kernel - kernel string as returned by 'uname -r'
    #
    # Prints:
    #     RHEL number, e.g. '5', '6', '7', or '8'

    local running_kernel="$1"

    local rhel
    rhel=$( sed -r -n 's/^.*el([[:digit:]]).*$/\1/p' <<< "$running_kernel" )
    echo "$rhel"
}


get_virtualization() {
    # Gets virtualization type.
    #
    # Prints:
    #     Virtualization type, "None", or "virt-what not available"

    local virt

    if command -v virt-what &> /dev/null; then
        virt=$( virt-what 2>&1 | tr '\n' ' ' )
        if [[ "$virt" ]]; then
            echo "$virt"
        else
            echo "None"
        fi
    else
        echo "virt-what not available"
    fi
}


set_default_values() {
    avail_vuln_file=0
    vuln_file_value=""
    cpu_vendor="Unknown"
    cpu_model_name=""
    cpu_model=""
    cpu_family=""
    cpu_stepping=""
    arch=""
    ec2=0

    cpu_not_affected=0
    vulnerable_mds=0
    vulnerable_smt=0
    mitigation_disabled=0
    microcode_not_detected=0
    result=0
}


parse_facts() {
    # Gathers all available information and stores it in global variables. Only store facts and
    # do not draw conclusion in this function for better maintainability.
    #
    # Side effects:
    #     Sets many global boolean flags and content variables
    #
    # Notes:
    #     MOCK_VULN_FILE_PATH can be used to mock /sys/devices/system/cpu/vulnerabilities/mds file
    #     MOCK_CPU_INFO_PATH can be used to mock /proc/cpuinfo file
    #     MOCK_DMESG_PATH can be used to mock /var/log/dmesg file
    #     MOCK_UUID_PATH can be used to mock /sys/hypervisor/uuid

    local vuln_file_path=${MOCK_VULN_FILE_PATH:-/sys/devices/system/cpu/vulnerabilities/mds}
    local cpuinfo_path=${MOCK_CPU_INFO_PATH:-/proc/cpuinfo}
    local dmesg_path=${MOCK_DMESG_PATH:-/var/log/dmesg}
    local uuid_path=${MOCK_UUID_PATH:-/sys/hypervisor/uuid}

    # Parse vulnerability file
    if [[ -r "${vuln_file_path}" ]]; then
        avail_vuln_file=1
        vuln_file_value=$( <"${vuln_file_path}" )
    fi

    # Parse CPU info for vendor data
    cpuinfo_value=$( <"${cpuinfo_path}" )
    if [[ "$cpuinfo_value" =~ "GenuineIntel" ]]; then
        cpu_vendor="Intel"
    elif [[ "$cpuinfo_value" =~ "AuthenticAMD" ]]; then
        cpu_vendor="AMD"
    elif [[ "$cpuinfo_value" =~ "POWER" ]]; then
        cpu_vendor="POWER"
    fi

    # Parse CPU info for model data
    if [[ "$cpu_vendor" == "Intel" || "$cpu_vendor" == "AMD" ]]; then
        cpu_model_name="$( awk '/model name/ { for(i = 4; i < NF; i++) printf "%s ", $i; print $i; exit }' <<< "$cpuinfo_value" )"
        cpu_model="$( awk '/model/ && NF == 3 { print $3; exit }' <<< "$cpuinfo_value" )"
        cpu_family="$( awk '/cpu family/ { print $4; exit }' <<< "$cpuinfo_value" )"
        cpu_stepping="$( awk '/stepping/ { print $3; exit }' <<< "$cpuinfo_value" )"
    elif [[ "$cpu_vendor" == "POWER" ]]; then
        cpu_model_name="$( awk '/cpu/ { for(i = 3; i < NF; i++) printf "%s ", $i; print $i; exit }' <<< "$cpuinfo_value" )"
    else
        # Fallback
        cpu_model_name="$( awk '/model name/ { for(i = 4; i < NF; i++) printf "%s ", $i; print $i; exit }' <<< "$cpuinfo_value" )"
    fi

    # Store architecture as `uname -r` does not contain it on RHEL5
    arch=$( uname -m )

    # Find if EC2 signature is in dmesg
    if dmesg | grep -q "Amazon EC2"; then
        ec2=1
    fi
    # Sometimes dmesg circular buffer already wrapped
    if grep -q -s "Amazon EC2" "$dmesg_path"; then
        ec2=1
    fi
    # Look for the presence of the "ec2" or "EC2" in the beginning of the UUID
    if grep -E -q -s -i "^ec2" "$uuid_path"; then
        ec2=1
    fi
}

draw_conclusions() {
    # Draws conclusions based on available system data.
    #
    # Side effects:
    #     Sets many global boolean flags and content variables

    # Check vulnerability
    # Vulnerability file combinations:
    # 'Not affected' = The processor is not vulnerable
    # 'Vulnerable' = The processor is vulnerable, but no mitigation enabled
    # 'Vulnerable: Clear CPU buffers attempted'	= The processor is vulnerable but microcode is not
    #                                             updated. The mitigation is enabled on a best
    #                                             effort basis.
    # 'Mitigation: CPU buffer clear' = The processor is vulnerable and the CPU buffer clearing
    #                                  mitigation is enabled.
    #
    # 'SMT vulnerable' = SMT is enabled
    # 'SMT mitigated' = SMT is enabled and mitigated
    # 'SMT disabled' = SMT is disabled
    # 'SMT Host state unknown' = Kernel runs in a VM, Host SMT state unknown
    if (( avail_vuln_file )); then
        if [[ "$vuln_file_value" =~ "Vulnerable" ]]; then
            vulnerable_mds=1
            if [[ "$vuln_file_value" =~ "Clear CPU buffers attempted" ]]; then
                microcode_not_detected=1
            else
                mitigation_disabled=1
            fi
        fi
        if [[ "$vuln_file_value" =~ "SMT vulnerable" ]]; then
            vulnerable_smt=1
        fi
    else
        vulnerable_mds=1
        vulnerable_smt=1
    fi

    # Check not affected CPUs - check known not affected CPUs first...
    if [[ "$cpu_vendor" == "Intel" ]]; then
        if (( cpu_family == 6 )); then
            if (( cpu_model == 85 && cpu_stepping != 4 )); then  # cascadelake
                cpu_not_affected=1
            elif (( cpu_model == 0x7A )); then  # geminilake/goldmontplus
                cpu_not_affected=1
            elif (( cpu_model == 0x5F )); then  # denverton/goldmontx
                cpu_not_affected=1
            elif (( cpu_model == 0x5C )); then  # goldmont
                cpu_not_affected=1
            fi
        fi
    else
        cpu_not_affected=1
    fi

    # ...then rely on vulnerability file
    if (( ! cpu_not_affected && avail_vuln_file )); then
        if [[ "$vuln_file_value" =~ "Not affected" ]]; then
            cpu_not_affected=1
        fi
    fi

    # Result values
    if (( cpu_not_affected || (! vulnerable_mds && ! vulnerable_smt) )); then
        result=0
    elif (( ! avail_vuln_file )); then
        result=2
    elif (( vulnerable_mds && ec2 )); then
        # EC2 instances are patched on the infrastructure level and it cannot be detected from guest
        result=0
    elif (( vulnerable_mds )); then
        result=3
    else
        result=4  # SMT only
    fi
}


debug_print() {
    # Prints selected variables when debugging is enabled.

    variables=( running_kernel rhel virtualization
                avail_vuln_file vuln_file_value
                cpu_vendor cpu_model_name cpu_model cpu_family cpu_stepping arch
                cpu_not_affected vulnerable_mds vulnerable_smt
                mitigation_disabled microcode_not_detected ec2 result
               )
    for variable in "${variables[@]}"; do
        echo "$variable = *${!variable}*"
    done
    echo
}


require_root() {
    # Checks if user is root.
    #
    # Side effects:
    #     Exits when user is not root.
    #
    # Notes:
    #     MOCK_EUID can be used to mock EUID variable

    local euid=${MOCK_EUID:-$EUID}

    # Am I root?
    if (( euid != 0 )); then
        echo "This script must run with elevated privileges (e.g. as root)"
        exit 1
    fi
}


if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    require_root  # Needed for virt-what
    basic_args "$@"
    basic_reqs "CVE-2018-12126, CVE-2018-12130, CVE-2018-12127, and CVE-2019-11091"
    running_kernel=$( uname -r )
    check_supported_kernel "$running_kernel"

    rhel=$( get_rhel "$running_kernel" )
    if (( rhel == 5 )); then
        export PATH="/sbin:/usr/sbin:$PATH"
    fi

    virtualization=$( get_virtualization )

    set_default_values
    parse_facts
    draw_conclusions

    # Debug prints
    if [[ "$debug" ]]; then
        debug_print
    fi

    # Outputs
    echo -e "Detected CPU vendor: ${BOLD}$cpu_vendor${RESET}"
    echo -e "CPU: ${BOLD}$cpu_model_name${RESET}"
    if [[ "$cpu_model" ]]; then
        printf "CPU model: ${BOLD}%d${RESET} (0x%x)\\n" "$cpu_model" "$cpu_model"
    fi
    echo -e "Running kernel: ${BOLD}$running_kernel${RESET}"
    echo -e "Architecture: ${BOLD}$arch${RESET}"
    echo -e "Virtualization: ${BOLD}$virtualization${RESET}"
    echo

    # Results
    if (( cpu_not_affected )); then
        echo -e "${GREEN}This CPU is not affected.${RESET}"
    elif (( ! avail_vuln_file )); then
        echo -e "${RED}Vulnerable${RESET}"
        echo
        echo -e "* Running kernel does not have the mitigation"
        echo -e "* CPU microcode update ${BOLD}may${RESET} be also needed"
        echo -e "* SMT ${BOLD}may${RESET} also need to be disabled"
    elif (( vulnerable_mds && ec2 )); then
        # EC2 instances are patched on the infrastructure level and it cannot be detected from guest
        echo -e "${GREEN}Mitigated on infrastructure level${RESET}"
        echo
        # SMT cannot be detected in VM anyway so skip any SMT messages
        echo -e "Even if kernel reports that the system is vulnerable, Amazon EC2"
        echo -e "instances have ${BOLD}mitigation applied${RESET} on infrastructure level."
        echo -e "See the following security advisory for more details:"
        echo -e "* https://aws.amazon.com/security/security-bulletins/AWS-2019-004/"
    elif (( vulnerable_mds )); then
        echo -e "${RED}${vuln_file_value}${RESET}"
        echo
        if (( microcode_not_detected )); then
            echo -e "* CPU microcode update is not detected"
        fi
        if (( mitigation_disabled )); then
            echo -e "* MDS mitigation disabled"
        fi
        if (( vulnerable_smt )); then
            echo -e "* SMT is vulnerable"
        fi
    elif (( vulnerable_smt )); then  # SMT only
        echo -e "${YELLOW}${vuln_file_value}${RESET}"
        echo
        echo -e "* SMT is vulnerable"
    else
        echo -e "${GREEN}${vuln_file_value}${RESET}"
    fi
    echo

    # Additional information
    echo -e "For more information about the vulnerabilities see:"
    echo -e "* $ARTICLE"
    echo

    # Additional conditional notes
    if (( result != 0 )); then  # Only if there is still a problem
        if (( vulnerable_smt )); then
            echo -e "${BOLD}Please refer to the above vulnerability article to decide if it${RESET}"
            echo -e "${BOLD}is necessary to disable SMT in your environment.${RESET}"
            echo
        fi
        if [[ "$virtualization" != "None" ]]; then
            echo -e "For more information about correctly enabling mitigations in VMs, see:"
            echo -e "* https://access.redhat.com/articles/3331571"
            echo -e "(This is Spectre related article, but the steps are the same)"
            echo
        fi
        if [[ "$virtualization" =~ "vmware" ]]; then
            echo -e "For more information about correctly enabling mitigations in VMWare VMs, see:"
            echo -e "* https://kb.vmware.com/s/article/52085"
            echo -e "(This is Spectre related article, but the steps should be similar)"
            echo
        fi
        if (( vulnerable_smt )); then
            echo -e "For more information about SMT and how to disable it if needed, see:"
            echo -e "* https://access.redhat.com/solutions/rhel-smt"
            echo
        fi
    fi

    exit "$result"
fi
