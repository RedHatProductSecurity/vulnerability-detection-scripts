#!/bin/bash

# Copyright (c) 2021  Red Hat, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

VERSION="1.3"

# Warning! Be sure to download the latest version of this script from its primary source:

BULLETIN="https://access.redhat.com/security/vulnerabilities/RHSB-2021-009"

# DO NOT blindly trust any internet sources and NEVER do `curl something | bash`!

# exit on empty variables
set -u

# exit on non-zero status (together with 'set -u', empty variables make the non-zero status propagate out of a subshell)
set -e

# dotglob: match hidden files/dirs, but not . and ..
# nullglob: if there's no glob match, do not resolve the glob to the nonexistent file name "*"
# extglob: allow globs like !(0) that are like * but ignore files named '0'
shopt -s dotglob nullglob extglob


# CHANGELOG
# v1.0
# v1.1 - updated to handle filenames with leading dash properly
# v1.2 - updated to handle archives that contain duplicate filenames, and to display permission error messages earlier and in more detail
# v1.3 - updated to recognize fixed versions 2.3.1, 2.3.2, 2.12.3, 2.12.4 (2.12.2 was already recognized by v1.0-v1.2); fixed code comments; uncompressed temporary files are deleted after individual processing during execution to reduce disk space usage


# NOTE about file creation and deletion safety and the auditing thereof
# ---------------------------------------------------------------------
#
# Creating and deleting files & directories is sensitive and can cause damage
# if done on the wrong path. This script modifies files and directories only
# through vetted code paths. It is easy to review the basic claims even
# without auditing the more advanced redundant checks:
#
# * User-supplied paths are saved into global variables scan_path, tmp_path,
#   audit_scan_path, and audit_tmp_path.
#
# * These paths are ensured to be canonical in basic_args().
#   (That means, absolute paths that can't have symlinks in the path.)
#
# * The variables scan_path, tmp_path, audit_scan_path, audit_tmp_path
#   are never modified, except for being set once in basic_args().
#
# * The variables scan_path and tmp_path are read many times in the script,
#   so for the purpose of making security audits easier, the variables
#   audit_scan_path and audit_tmp_path are used only in 'rm' operations.
#
# * All 'rm' operation are of a similar form and are surrounded by similar
#   sanity checks.
#
# * There are no other 'rm' operations, nor anything even slightly similar,
#   like 'mv'.
#
# * The variable audit_scan_path is never read, because that is exactly in
#   accordance with these claims.
#
# * Any files/directories deleted by this script are strictly temporary
#   files/directories created by this script inside user-provided $tmp_path.
#
# * Before each 'rm' operation, audit_tmp_path is checked to be non-empty and
#   identical to tmp_path.
#
# * Additionally, unassigned variables make the script exit immediately, due
#   to the 'set -u' and 'set -e' setting.
#
# * Before each file / directory creation or modification operation, the path
#   is checked to be inside tmp_path.
#
# * Before each file / directory read operation, the path is checked to be
#   inside tmp_path or scan_path.
#
# * These claims are checkable by anyone with moderate Bash proficiency and a
#   basic text editor with string search capability.
#
# * Everyone is welcome to perform a thorough review to see there are no
#   other avenues for malicious 'rm'.


set_default_values() {
    # Sets default global variable values.
    #
    # Side effects:
    #     Sets global variables.

    RED=""
    GREEN=""
    BOLD=""
    RESET=""
    num_before="n1"
    num_after="n2"
    POM_PATH="META-INF/maven/org.apache.logging.log4j/log4j-core/pom.xml"
    vulnerable=0
    result=0
    queue_position=0
    queue_length=0
    queue_length_check=0
    running_kernel=""
    scan_path="/dev/null"
    tmp_path="/dev/null"
    print_progress=1

    readonly queue="CVE_2021_44228_queue"
    readonly catalog="CVE_2021_44228_catalog"
    readonly decompressed="CVE_2021_44228_decompressed"
    readonly parents="CVE_2021_44228_parents"
    readonly backtrack="CVE_2021_44228_backtrack"
    readonly detections="CVE_2021_44228_detections"
    readonly report="report"
}


print_help() {
    echo "Usage: $( basename "$0" ) [-n | --no-colors] [-d | --debug] [--no-progress] --scan SCANPATH --tmp TMPPATH"
    echo
    echo "* SCANPATH will be recursively searched for vulnerable log4j-core jar files,"
    echo "  unpacking zip and jar files along the way. Symbolic links are not followed."
    echo "  Only local filesystem paths are supported."
    echo
    echo "* TMPPATH must be a writable empty directory. After the script finishes, it"
    echo "  will contain the subdirectory 'report' with .txt files, each containing"
    echo "  path to a vulnerable log4j-core jar file. There must be enough available"
    echo "  space in TMPPATH, roughly 30 times the size of SCANPATH, otherwise the"
    echo "  result will be incomplete."
    echo
    echo "* Both paths must be canonical (absolute). Relative paths and paths that"
    echo "  traverse through symlinks are not supported. TMPPATH must not be inside"
    echo "  SCANPATH."
}


print_debug() {
    # Prints selected variables when debugging is enabled.
    if (( debug )); then
        echo
        variables=( running_kernel vulnerable result scan_path tmp_path num_before num_after queue_position queue_length queue_length_check )
        for variable in "${variables[@]}"; do
            echo "$variable = *${!variable}*"
        done
        echo
    fi
}


basic_args() {
    # Parses basic commandline arguments and sets basic environment.
    #
    # Args:
    #     parameters - an array of commandline arguments
    #
    # Side effects:
    #     Exits if --help parameters is used, or if provided arguments are not valid
    #     Sets COLOR constants and variables debug, scan_path, tmp_path, audit_scan_path, audit_tmp_path

    local parameters=( "$@" )

    RED="\\033[1;31m"
    GREEN="\\033[1;32m"
    BOLD="\\033[1m"
    RESET="\\033[0m"

    local processing_scanpath=0
    local processing_tmppath=0
    local found_scanpath=0
    local found_tmppath=0
    local scanpath=""
    local tmppath=""

    debug=0

    for parameter in "${parameters[@]}"; do
        if (( ! processing_scanpath && ! processing_tmppath )) && [[ "$parameter" == "-h" || "$parameter" == "--help" ]]; then
            print_help
            print_debug
            exit 1
        elif (( ! processing_scanpath && ! processing_tmppath )) && [[ "$parameter" == "-n" || "$parameter" == "--no-colors" ]]; then
            RED=""
            GREEN=""
            BOLD=""
            RESET=""
        elif (( ! processing_scanpath && ! processing_tmppath )) && [[ "$parameter" == "-d" || "$parameter" == "--debug" ]]; then
            debug=1
        elif (( ! processing_scanpath && ! processing_tmppath )) && [[ "$parameter" == "--no-progress" ]]; then
            print_progress=0
        elif (( ! processing_scanpath && ! processing_tmppath )) && [[ "$parameter" == "--scan" ]]; then
            processing_scanpath=1
        elif (( ! processing_scanpath && ! processing_tmppath )) && [[ "$parameter" == "--tmp" ]]; then
            processing_tmppath=1
        elif (( processing_scanpath )); then
            scanpath="$parameter"
            found_scanpath=1
            processing_scanpath=0
        elif (( processing_tmppath )); then
            tmppath="$parameter"
            found_tmppath=1
            processing_tmppath=0
        fi
    done

    if (( ! found_scanpath || ! found_tmppath )); then
        print_help
        print_debug
        exit 1
    fi

    if [[ ! -d "$scanpath" ]]; then
        echo "Error: SCANPATH doesn't exist or is not a directory. Exiting."
        echo
        print_help
        print_debug
        exit 1
    fi

    if [[ ! -d "$tmppath" ]]; then
        echo "Error: TMPPATH doesn't exist or is not a directory. Exiting."
        echo
        print_help
        print_debug
        exit 1
    fi

    # canonicalize path (strip trailing /, convert to absolute, follow symlink)
    scan_path="$( readlink -f -- "$scanpath" )"
    tmp_path="$( readlink -f -- "$tmppath" )"

    # strip trailing /
    scanpath="${scanpath%/}"
    tmppath="${tmppath%/}"

    # * Make sure the paths are canonical.
    # * Make sure the resolved paths are not empty strings (since they exist, they can't be empty, as long as the provided and canonicalized paths are equal).
    if [[ "$scan_path" != "$scanpath" ]] ; then
        echo "Error: SCANPATH is not a canonical path. Please use absolute paths, for example /opt/something/something. Exiting."
        echo
        print_help
        print_debug
        exit 1
    fi

    if [[ "$tmp_path" != "$tmppath" ]] ; then
        echo "Error: TMPPATH is not a canonical path. Please use absolute paths, for example /tmp/something/something. Make sure the path is not a symlink. Exiting."
        echo
        print_help
        print_debug
        exit 1
    fi

    local len_scanpath="${#scanpath}"
    local len_tmppath="${#tmppath}"

    if (( len_tmppath > len_scanpath )) ; then
        local prefix_of_tmppath="${tmppath:0:$len_scanpath}"
        if [[ "$prefix_of_tmppath" == "$scanpath" ]] ; then
            local char_after_prefix="${tmppath:$len_scanpath:1}"
            if [[ "$char_after_prefix" == "/" ]] ; then
                echo "Error: TMPPATH must not be a subdirectory of SCANPATH. Exiting."
                echo
                print_help
                print_debug
                exit 1
            fi
        fi
    fi

    audit_tmp_path="$tmp_path"
    audit_scan_path="$scan_path"

    readonly tmp_path
    readonly scan_path
    readonly audit_tmp_path

    # Unused on purpose. See the NOTE at the beginning.
    # shellcheck disable=SC2034
    readonly audit_scan_path
}


basic_reqs() {
    # Prints common disclaimer and checks basic requirements.
    #
    # Args:
    #     CVE - string printed in the disclaimer
    #
    # Side effects:
    #     Exits when a command is not available

    local CVE="$1"

    # Disclaimer
    echo
    echo -e "${BOLD}This script (v$VERSION) is primarily designed to detect $CVE on supported"
    echo -e "Red Hat Enterprise Linux 6-8 systems."
    echo -e "Result may be inaccurate for other systems."
    echo -e "Result may be inaccurate for affected log4j-core jar files other than those found"
    echo -e "in the two listed maven repositories as of 2021-12-13 and between versions"
    echo -e "2.0(.*) inclusive and 2.14.* inclusive:"
    echo -e "* https://maven.repository.redhat.com/ga/org/apache/logging/log4j/log4j-core/"
    echo -e "* https://repo1.maven.org/maven2/org/apache/logging/log4j/log4j-core/${RESET}"

    echo "Symbolic links are not followed. Only local filesystem paths are supported."
    echo

    # * readlink is required to canonicalize paths; it's installed by default on supported RHEL versions (coreutils)
    # * file is required to recognize zip/jar files; it's installed by default on supported RHEL versions (file)
    # * unzip is required to unpack zip/jar files; it's installed by default on RHEL 6 and 8, but not on 7 (unzip)
    # * stat is required to calculate file size; it's installed by default on supported RHEL versions (coreutils)
    # * sha256sum is required to deduplicate and catalog temporary files; it's installed by default on supported RHEL versions (coreutils)
    # * basename is required to deduplicate and catalog temporary files; it's installed by default on supported RHEL versions (coreutils)
    # * cat is required to deduplicate and catalog temporary files; it's installed by default on supported RHEL versions (coreutils)
    # * grep is required to deduplicate and catalog temporary files; it's installed by default on supported RHEL versions (grep)
    # * uname is required for debug output; it's installed by default on supported RHEL versions (coreutils)
    # * pwd is required during algorithm processing; it's installed by default on supported RHEL versions (coreutils)
    # * /bin/rm is required during algorithm processing and to clean temporary files at the end of execution; it's installed by default on supported RHEL versions (coreutils)
    for required_command in readlink file unzip stat sha256sum basename cat grep uname pwd /bin/rm ; do
        if ! command -v "$required_command" &> /dev/null; then
            echo "Error: '$required_command' command is required, but not installed. Exiting."
            if [[ "$required_command" == "unzip" ]] ; then
                # Be extra nice because a lot of systems are going to hit this.
                echo "Please run 'yum install unzip' before running this script."
            fi
            print_debug
            exit 1
        fi
    done
}


err_inaccessible() {
    # Prints an error message. Prints debug information if configured to do so.
    #
    # Side effects:
    #     Exits.

    echo "Error: The provided temporary directory is not accessible or can't be created. Please provide an empty and accessible temporary directory. Exiting."
    echo
    print_help
    print_debug
    exit 1
}


err_nonempty() {
    # Prints an error message. Prints debug information if configured to do so.
    #
    # Side effects:
    #     Exits.

    echo "Error: The provided temporary directory is not empty. Please provide an empty temporary directory. Exiting."
    echo
    print_help
    print_debug
    exit 1
}


err_internal_path_validation() {
    # Prints an error message. Prints debug information if configured to do so.
    #
    # Side effects:
    #     Exits.

    # We realize this is not helpful, but printing the string that triggered the check might itself be unsafe.
    # This should never happen, as long as sha256sum behaves as expected, and as long as TMPPATH and SCANPATH are not externally modified.
    echo "Error: An error occurred during internal file path validation. Please make sure only a single instance of the script runs and that TMPPATH nor SCANPATH is modified while the script runs. Exiting."
    print_debug
    exit 3
}

is_subpath() {
    # Checks that the following is true:
    # 1. The supplied base path ($1) is a subpath of the supplied proposed path ($2). That means:
    #    a. The supplied base path is not longer than the supplied proposed path.
    #    b. The supplied base path is a substring (starting at the beginning) of the supplied proposed path.
    #    c. After that substring, there is a slash in the supplied proposed path.
    #      (I.e. if $1 is /opt/something and $2 /opt/somethingelse, an error is produced.)
    # 2. Both paths are canonical.
    #    a. base path is canonical
    #    a. proposed path is canonical
    # 3. There are no /../ parts in the paths.
    #    a. base path
    #    a. proposed path
    # 4. There are no symlinks in the paths.
    #    a. base path
    #    a. proposed path
    #
    # Args:
    #     base_path_is - the base path
    #     proposed_path_is - the proposed path to check whether it's a subpath
    #
    # Side effects:
    #     Exits, if there's an issue.

    local base_path_is="$1"
    local proposed_path_is="$2"

    local len_base_path_is="${#base_path_is}"
    local len_proposed_path_is="${#proposed_path_is}"

    # This is for human review purposes. These checks correspond with the function's docstring.
    local check_1_a=0
    local check_1_b=0
    local check_1_c=0
    local check_2_a=0
    local check_2_b=0
    local check_3_a=0
    local check_3_b=0
    local check_4_a=0
    local check_4_b=0

    # A subpath can't be shorter! (If both are canonical.)
    if (( len_base_path_is > len_proposed_path_is )) ; then
        err_internal_path_validation  # exit 3
    else
        check_1_a=1
    fi

    local prefix_of_proposed_is="${proposed_path_is:0:$len_base_path_is}"

    # The "base" path must be the exact prefix of the "proposed" path
    if [[ "$prefix_of_proposed_is" != "$base_path_is" ]] ; then
        err_internal_path_validation  # exit 3
    else
        check_1_b=1
    fi

    local char_after_prefix_of_proposed_is="${proposed_path_is:$len_base_path_is:1}"

    # After that prefix, there must be a /
    if [[ "$char_after_prefix_of_proposed_is" != "/" ]] ; then
        err_internal_path_validation  # exit 3
    else
        check_1_c=1
    fi

    # Both supplied paths must be canonical. This eliminates symlinks and things like /../

    if [[ "$( readlink -f -- "$base_path_is" )" != "$base_path_is" ]] ; then
        err_internal_path_validation  # exit 3
    else
        check_2_a=1
        check_3_a=1
        check_4_a=1
    fi

    if [[ "$( readlink -f -- "$proposed_path_is" )" != "$proposed_path_is" ]] ; then
        err_internal_path_validation  # exit 3
    else
        check_2_b=1
        check_3_b=1
        check_4_b=1
    fi

    if (( check_1_a && check_1_b && check_1_c && check_2_a && check_2_b && check_3_a && check_3_b && check_4_a && check_4_b )) ; then
        return 0
    else
        err_internal_path_validation  # exit 3
    fi
}


validate_path_tmp() {
    # Checks that the $proposed_path_vpt is a subpath of $base_path_vpt and
    # that both are subpaths of $tmp_path.
    #
    # Args:
    #     base_path_vpt - the base path we deem as generally safe for manipulation
    #     proposed_path_vpt - the proposed path to check for issues
    #
    # Side effects:
    #     Exits, if there's an issue.

    local base_path_vpt="$1"
    local proposed_path_vpt="$2"

    # The supplied base path must be a subpath of $tmp_path, which we treat as trusted (absolute canonical user-supplied path),
    # or it must be identical to $tmp_path
    if [[ "$base_path_vpt" != "$tmp_path" ]] ; then
        is_subpath "$tmp_path" "$base_path_vpt"
    fi

    # The supplied proposed path must be a subpath of the supplied base path
    is_subpath "$base_path_vpt" "$proposed_path_vpt"

    # Note that is_subpath calls "exit 3" if any of the claims are not true / if any of the checks fail
}


validate_path_scan() {
    # Checks that the $proposed_path_vps is a subpath of $base_path_vps and
    # that both are subpaths of $scan_path.
    #
    # Args:
    #     base_path_vps - the base path we deem as generally safe for manipulation
    #     proposed_path_vps - the proposed path to check for issues
    #
    # Side effects:
    #     Exits, if there's an issue.

    local base_path_vps="$1"
    local proposed_path_vps="$2"

    # The supplied base path must be a subpath of $scan_path, which we treat as trusted (absolute canonical user-supplied path),
    # or it must be identical to $scan_path
    if [[ "$base_path_vps" != "$scan_path" ]] ; then
        is_subpath "$scan_path" "$base_path_vps"
    fi

    # The supplied proposed path must be a subpath of the supplied base path
    is_subpath "$base_path_vps" "$proposed_path_vps"

    # Note that is_subpath calls "exit 3" if any of the claims are not true / if any of the checks fail
}


safe_mkdir_parents() {
    # Creates $newdir under $tmp_path/$parents.
    #
    # Args:
    #     newdir - directory to create under $tmp_path/$parents
    #
    # Side effects:
    #     Exits, if there's an issue, such as $newdir being outside $tmp_path/$parents.

    local newdir="$1"

    # Note that the '-p' argument makes mkdir not complain if the directory already exists.

    # Yes, $tmp_path/$parents == $tmp_path/CVE_2021_44228_parents, but the point of using the second expression is to very clearly show where the new dir is being created
    validate_path_tmp "$tmp_path/$parents" "$tmp_path/CVE_2021_44228_parents/$newdir"
    mkdir -p "$tmp_path/$parents/$newdir"
}


safe_mkdir_decompressed() {
    # Creates $newdir under $tmp_path/$decompressed.
    #
    # Args:
    #     newdir - directory to create under $tmp_path/$decompressed
    #
    # Side effects:
    #     Exits, if there's an issue, such as $newdir being outside $tmp_path/$decompressed.

    local newdir="$1"

    # Yes, $tmp_path/$decompressed == $tmp_path/CVE_2021_44228_decompressed, but the point of using the second expression is to very clearly show where the new dir is being created
    validate_path_tmp "$tmp_path/$decompressed" "$tmp_path/CVE_2021_44228_decompressed/$newdir"
    mkdir "$tmp_path/$decompressed/$newdir"
}


safe_mkdir_backtrack() {
    # Creates $newdir under $tmp_path/$backtrack.
    #
    # Args:
    #     newdir - directory to create under $tmp_path/$backtrack
    #
    # Side effects:
    #     Exits, if there's an issue, such as $newdir being outside $tmp_path/$backtrack.

    local newdir="$1"

    # Note that the '-p' argument makes mkdir not complain if the directory already exists.

    # Yes, $tmp_path/$backtrack == $tmp_path/CVE_2021_44228_backtrack, but the point of using the second expression is to very clearly show where the new dir is being created
    validate_path_tmp "$tmp_path/$backtrack" "$tmp_path/CVE_2021_44228_backtrack/$newdir"
    mkdir -p "$tmp_path/$backtrack/$newdir"
}


safe_echo_parents() {
    # Does 'echo $str > $tmp_path/$parents/$dst'.
    #
    # Args:
    #     str - string to be echoed into a file
    #     dst - file path where to save the string
    #
    # Side effects:
    #     Exits, if there's an issue, such as $dst being outside $tmp_path/$parents.

    local str="$1"
    local dst="$2"

    # Yes, $tmp_path/$parents == $tmp_path/CVE_2021_44228_parents, but the point of using the second expression is to very clearly show where the file is being written
    validate_path_tmp "$tmp_path/$parents" "$tmp_path/CVE_2021_44228_parents/$dst"
    echo "$str" > "$tmp_path/$parents/$dst"
}


safe_echo_backtrack() {
    # Does 'echo $str > $tmp_path/$backtrack/$dst'.
    #
    # Args:
    #     str - string to be echoed into a file
    #     dst - file path where to save the string
    #
    # Side effects:
    #     Exits, if there's an issue, such as $dst being outside $tmp_path/$backtrack.

    local str="$1"
    local dst="$2"

    # Yes, $tmp_path/$backtrack == $tmp_path/CVE_2021_44228_backtrack, but the point of using the second expression is to very clearly show where the file is being written
    validate_path_tmp "$tmp_path/$backtrack" "$tmp_path/CVE_2021_44228_backtrack/$dst"
    echo "$str" > "$tmp_path/$backtrack/$dst"
}


safe_echo_report() {
    # Does 'echo $str > $tmp_path/$report/$dst'.
    #
    # Args:
    #     str - string to be echoed into a file
    #     dst - file path where to save the string
    #
    # Side effects:
    #     Exits, if there's an issue, such as $dst being outside $tmp_path/$report.

    local str="$1"
    local dst="$2"

    # Yes, $tmp_path/$report == $tmp_path/report, but the point of using the second expression is to very clearly show where the new file is being written
    validate_path_tmp "$tmp_path/$report" "$tmp_path/report/$dst"
    echo "$str" > "$tmp_path/report/$dst"
}


validate_path_inside_scan_or_tmp() {
    # Checks that $src is a subpath of $scan_path or of $tmp_path.
    #
    # Args:
    #     src - path to be validated
    #
    # Side effects:
    #     Exits, if there's an issue, or if the answer is "no".

    local src="$1"
    local len_src="${#src}"
    local scan_path_with_slash="$scan_path/"
    local len_scan_path="${#scan_path_with_slash}"

    local probably_inside_scan_path=0

    if (( len_src > len_scan_path )) ; then
        local src_prefix="${src:0:$len_scan_path}"
        if [[ "$src_prefix" == "$scan_path_with_slash" ]] ; then
            probably_inside_scan_path=1
        fi
    fi

    # Forbid reading from anywhere else than inside scan_path or tmp_path
    if (( probably_inside_scan_path )) ; then
        validate_path_scan "$scan_path" "$src"
    else
        validate_path_tmp "$tmp_path" "$src"
    fi
}


safe_cp_queue() {
    # Does 'cp $src $tmp_path/$queue/$dst'. Checks that $src is a subpath of $scan_path or
    # $tmp_path and checks that '$tmp_path/$queue/$dst' doesn't get outside of $tmp_path/$queue.
    #
    # Args:
    #     src
    #     dst
    #
    # Side effects:
    #     Exits, if there's an issue.

    local src="$1"
    local dst="$2"

    # Forbid reading from anywhere else than inside scan_path or tmp_path
    validate_path_inside_scan_or_tmp "$src"

    # Yes, $tmp_path/$queue == $tmp_path/CVE_2021_44228_queue, but the point of using the second expression is to very clearly show where the new file is being created
    validate_path_tmp "$tmp_path/$queue" "$tmp_path/CVE_2021_44228_queue/$dst"

    if [[ ! -f "$src" ]] ; then
        err_internal_path_validation
    fi

    cp "$src" "$tmp_path/$queue/$dst"
}


safe_sha256_sum_from_string() {
    # Returns a sha256hash of the string in the argument $src.
    #
    # Args:
    #     src - the string to be hashed
    #
    # Side effects:
    #     Exits, if there's an issue, such as invalid sha256sum output.

    local src="$1"
    local hash
    hash="$( echo "$src" | sha256sum )"
    hash="${hash%% *}"
    if [[ $hash =~ ^[01-9a-f]{64}$ ]] ; then
        echo "$hash"
    else
        echo "Error: There's a file that makes sha256sum output non-standard. This is highly suspicious. Aborting." >&2
        exit 3
    fi
}


safe_sha256_sum_from_file() {
    # Returns a sha256hash of the file in the path $src. Checks that $src is a
    # subpath of $scan_path or $tmp_path.
    #
    # Args:
    #     src - the file to be hashed
    #
    # Side effects:
    #     Exits, if there's an issue, such as invalid sha256sum output, or $src
    #     outside of allowed paths.

    local src="$1"

    # Forbid reading from anywhere else than inside scan_path or tmp_path
    validate_path_inside_scan_or_tmp "$src"

    if [[ ! -f "$src" ]] ; then
        err_internal_path_validation
    fi

    local hash
    hash="$( sha256sum -- "$src" )"
    hash="${hash%% *}"

    if [[ $hash =~ ^[01-9a-f]{64}$ ]] ; then
        echo "$hash"
    else
        echo "Error: There's a file that makes sha256sum output non-standard. This is highly suspicious. Aborting." >&2
        exit 3
    fi
}


safe_cat_parents() {
    # Does 'cat $tmp_path/$parents/$src'.
    #
    # Args:
    #     src - file to read and return via stdout, located under $tmp_path/$parents
    #
    # Side effects:
    #     Exits, if there's an issue, such as $src pointint outside of allowed
    #     path, or $src not existing.

    local src="$1"

    # Yes, $tmp_path/$parents == $tmp_path/CVE_2021_44228_parents, but the point of using the second expression is to very clearly show where the file is being read from
    validate_path_tmp "$tmp_path/$parents" "$tmp_path/CVE_2021_44228_parents/$src"

    if [[ ! -f "$tmp_path/$parents/$src" ]] ; then
        err_internal_path_validation
    fi

    cat "$tmp_path/$parents/$src"
}


safe_cat_backtrack() {
    # Does 'cat $tmp_path/$backtrack/$src'.
    #
    # Args:
    #     src - file to read and return via stdout, located under $tmp_path/$backtrack
    #
    # Side effects:
    #     Exits, if there's an issue, such as $src pointint outside of allowed
    #     path, or $src not existing.

    local src="$1"

    # Yes, $tmp_path/$backtrack == $tmp_path/CVE_2021_44228_backtrack, but the point of using the second expression is to very clearly show where the file is being read from
    validate_path_tmp "$tmp_path/$backtrack" "$tmp_path/CVE_2021_44228_backtrack/$src"

    if [[ ! -f "$tmp_path/$backtrack/$src" ]] ; then
        err_internal_path_validation
    fi

    cat "$tmp_path/$backtrack/$src"
}


safe_rm_rf_backtrack() {
    # Does 'rm -rf $tmp_path/$backtrack/$dir_to_delete'. Checks that $dir_to_delete is a subpath of $tmp_path/$backtrack.
    #
    # Args:
    #     dir_to_delete - the directory to recursively delete, under $tmp_path/$backtrack
    #
    # Side effects:
    #     Exits, if there's an issue, such as $dir_to_delete outside of allowed
    #     path, not existing, or containing .. or /

    local dir_to_delete="$1"

    # Yes, $tmp_path/$backtrack == $tmp_path/CVE_2021_44228_backtrack, but the point of using the second expression is to very clearly show where the new dir is being deleted
    validate_path_tmp "$tmp_path/$backtrack" "$tmp_path/CVE_2021_44228_backtrack/$dir_to_delete"

    if [[ ! -d "$tmp_path/$backtrack/$dir_to_delete" ]] ; then
        err_internal_path_validation
    fi

    # The checks are technically redundant, but make auditing easier.
    if [[ -d "$tmp_path/$backtrack/$dir_to_delete" && ! -L "$tmp_path/$backtrack/$dir_to_delete"  ]] ; then
        if [[ "$dir_to_delete" != *..* && "$dir_to_delete" != */* ]] ; then
            if [[ "$tmp_path/$backtrack/$dir_to_delete" == "$audit_tmp_path/$backtrack/$dir_to_delete" ]] ; then
                # Note that "${var:?}" fails on purpose if $var is null or unset (empty). See https://github.com/koalaman/shellcheck/wiki/SC2115
                ( cd -- "${audit_tmp_path:?}" && /bin/rm -rf --one-file-system -- "${backtrack:?}/${dir_to_delete:?}" ; )
            fi
        fi
    fi
}


safe_rm_rf_decompressed() {
    # Does 'rm -rf $tmp_path/$decompressed/$dir_to_delete'. Checks that $dir_to_delete is a subpath of $tmp_path/$decompressed.
    #
    # Args:
    #     dir_to_delete - the directory to recursively delete, under $tmp_path/$decompressed
    #
    # Side effects:
    #     Exits, if there's an issue, such as $dir_to_delete outside of allowed
    #     path, not existing, or containing .. or /

    local dir_to_delete="$1"

    # Yes, $tmp_path/$decompressed == $tmp_path/CVE_2021_44228_decompressed, but the point of using the second expression is to very clearly show where the new dir is being deleted
    validate_path_tmp "$tmp_path/$decompressed" "$tmp_path/CVE_2021_44228_decompressed/$dir_to_delete"

    if [[ ! -d "$tmp_path/$decompressed/$dir_to_delete" ]] ; then
        err_internal_path_validation
    fi

    # The checks are technically redundant, but make auditing easier.
    if [[ -d "$tmp_path/$decompressed/$dir_to_delete" && ! -L "$tmp_path/$decompressed/$dir_to_delete"  ]] ; then
        if [[ "$dir_to_delete" != *..* && "$dir_to_delete" != */* ]] ; then
            if [[ "$tmp_path/$decompressed/$dir_to_delete" == "$audit_tmp_path/$decompressed/$dir_to_delete" ]] ; then
                # Note that "${var:?}" fails on purpose if $var is null or unset (empty). See https://github.com/koalaman/shellcheck/wiki/SC2115
                ( cd -- "${audit_tmp_path:?}" && /bin/rm -rf --one-file-system -- "${decompressed:?}/${dir_to_delete:?}" ; )
            fi
        fi
    fi
}


safe_touch_catalog() {
    # Creates or 'touch'es a file $newfile under $tmp_path/$catalog.
    #
    # Args:
    #     newfile - file to create or 'touch' under $tmp_path/$catalog
    #
    # Side effects:
    #     Exits, if there's an issue, such as the resulting path being outside
    #     $tmp_path/$catalog.

    local newfile="$1"

    # Yes, $tmp_path/$catalog == $tmp_path/CVE_2021_44228_catalog, but the point of using the second expression is to very clearly show where the new file is being created
    validate_path_tmp "$tmp_path/$catalog" "$tmp_path/CVE_2021_44228_catalog/$newfile"

    touch "$tmp_path/$catalog/$newfile"
}


safe_touch_detections() {
    # Creates or 'touch'es a file $newfile under $tmp_path/$detections.
    #
    # Args:
    #     newfile - file to create or 'touch' under $tmp_path/$detections
    #
    # Side effects:
    #     Exits, if there's an issue, such as the resulting path being outside
    #     $tmp_path/$detections.

    local newfile="$1"

    # Yes, $tmp_path/$detections == $tmp_path/CVE_2021_44228_detections, but the point of using the second expression is to very clearly show where the new file is being created
    validate_path_tmp "$tmp_path/$detections" "$tmp_path/CVE_2021_44228_detections/$newfile"

    touch "$tmp_path/$detections/$newfile"
}


get_queue_length() {
    # Returns the number of files under $tmp_path/$queue.

    local queue_files_for_counting=( "$tmp_path/$queue"/q-*-* )
    local num="${#queue_files_for_counting[@]}"
    echo "$num"
}


prepare_directories() {
    # Prepares temporary and result report directories under tmp_path for the
    # detection algorithm's operation.
    #
    # Side effects:
    #     Exits, if there's an issue, such as non-writable tmp_path.
    (
        cd -- "$tmp_path" || err_inaccessible

        local are_there_files=(*)
        if (( "${#are_there_files[@]}" != 0 )) ; then
            err_nonempty
        fi
    )

    validate_path_tmp "$tmp_path" "$tmp_path/$queue"
    validate_path_tmp "$tmp_path" "$tmp_path/$catalog"
    validate_path_tmp "$tmp_path" "$tmp_path/$decompressed"
    validate_path_tmp "$tmp_path" "$tmp_path/$parents"
    validate_path_tmp "$tmp_path" "$tmp_path/$backtrack"
    validate_path_tmp "$tmp_path" "$tmp_path/$detections"
    validate_path_tmp "$tmp_path" "$tmp_path/$report"

    mkdir "$tmp_path/$queue" || err_inaccessible
    mkdir "$tmp_path/$catalog" || err_inaccessible
    mkdir "$tmp_path/$decompressed" || err_inaccessible
    mkdir "$tmp_path/$parents" || err_inaccessible
    mkdir "$tmp_path/$backtrack" || err_inaccessible
    mkdir "$tmp_path/$detections" || err_inaccessible
    mkdir "$tmp_path/$report" || err_inaccessible
}


delete_directories() {
    # Deletion is a sensitive operation. The checks here are painfully redundant.
    # This is to make it clear to reviewers that it is not possible for files
    # outside user-specified TMPPATH to get deleted. See the NOTE at the beginning
    # for more details.

    # All of these must turn non-zero for deletion to occur.
    local ok_tmp_path=0
    local ok_queue=0
    local ok_catalog=0
    local ok_decompressed=0
    local ok_parents=0
    local ok_backtrack=0
    local ok_detections=0
    local ok_report=0

    local check_queue
    local check_catalog
    local check_decompressed
    local check_parents
    local check_backtrack
    local check_detections
    local check_report

    # All these paths should already be canonical, so let's canonicalize them again to check again.
    check_queue="$(        readlink -f -- "$tmp_path/$queue"        || exit 1 )"
    check_catalog="$(      readlink -f -- "$tmp_path/$catalog"      || exit 1 )"
    check_decompressed="$( readlink -f -- "$tmp_path/$decompressed" || exit 1 )"
    check_parents="$(      readlink -f -- "$tmp_path/$parents"      || exit 1 )"
    check_backtrack="$(    readlink -f -- "$tmp_path/$backtrack"    || exit 1 )"
    check_detections="$(   readlink -f -- "$tmp_path/$detections"   || exit 1 )"
    check_report="$(       readlink -f -- "$tmp_path/$report"       || exit 1 )"

    # Making sure tmp_path didn't get emptied somewhere.
    # Making sure the temporary directory contains the right number of items.
    if [[ "$tmp_path" != "" ]] && [[ -d "$tmp_path" && ! -L "$tmp_path" ]] ; then
        local num_of_entries=0
        local tmp_path_problem=0
        local entry
        for entry in "$tmp_path"/* ; do
            num_of_entries="$(( num_of_entries + 1 ))"
            if ! [[ "$entry" == "$tmp_path/$queue" || "$entry" == "$tmp_path/$catalog" || "$entry" == "$tmp_path/$decompressed" || "$entry" == "$tmp_path/$parents" || "$entry" == "$tmp_path/$backtrack" || "$entry" == "$tmp_path/$detections" || "$entry" == "$tmp_path/$report" ]] ; then
                tmp_path_problem=1
            fi
        done
        if (( num_of_entries == 7 && !tmp_path_problem )) ; then
            ok_tmp_path=1
        fi
    fi

    # Making sure the variables didn't get changed somehow.
    # The directory existence checks ensure that even if a single directory is missing, nothing gets deleted.
    if [[ "$check_queue" == "$tmp_path/$queue" ]] && [[ "$check_queue" == "$tmp_path/CVE_2021_44228_queue" ]] ; then
        if [[ -d "$check_queue" && ! -L "$check_queue" ]] ; then
            ok_queue=1
        fi
    fi

    # By the way, note that all the temporary files have strings that are unlikely to occur in normal operations. Even if tmp_path resolved to something malicious and evaded all checks, only the final subdirectories with the peculiar strings would be deleted.
    if [[ "$check_catalog" == "$tmp_path/$catalog" ]] && [[ "$check_catalog" == "$tmp_path/CVE_2021_44228_catalog" ]] ; then
        if [[ -d "$check_catalog" && ! -L "$check_catalog" ]] ; then
            ok_catalog=1
        fi
    fi

    if [[ "$check_decompressed" == "$tmp_path/$decompressed" ]] && [[ "$check_decompressed" == "$tmp_path/CVE_2021_44228_decompressed" ]] ; then
        if [[ -d "$check_decompressed" && ! -L "$check_decompressed" ]] ; then
            ok_decompressed=1
        fi
    fi

    if [[ "$check_parents" == "$tmp_path/$parents" ]] && [[ "$check_parents" == "$tmp_path/CVE_2021_44228_parents" ]] ; then
        if [[ -d "$check_parents" && ! -L "$check_parents" ]] ; then
            ok_parents=1
        fi
    fi

    if [[ "$check_backtrack" == "$tmp_path/$backtrack" ]] && [[ "$check_backtrack" == "$tmp_path/CVE_2021_44228_backtrack" ]] ; then
        if [[ -d "$check_backtrack" && ! -L "$check_backtrack" ]] ; then
            ok_backtrack=1
        fi
    fi

    if [[ "$check_detections" == "$tmp_path/$detections" ]] && [[ "$check_detections" == "$tmp_path/CVE_2021_44228_detections" ]] ; then
        if [[ -d "$check_detections" && ! -L "$check_detections" ]] ; then
            ok_detections=1
        fi
    fi

    if [[ "$check_report" == "$tmp_path/$report" ]] && [[ "$check_report" == "$tmp_path/report" ]] ; then
        if [[ -d "$check_report" && ! -L "$check_report" ]] ; then
            ok_report=1
        fi
    fi

    if (( ok_tmp_path && ok_queue && ok_catalog && ok_decompressed && ok_parents && ok_backtrack && ok_detections && ok_report )) ; then

        # The checks are technically redundant, but make auditing easier.
        # Note that "${var:?}" fails on purpose if $var is null or unset (empty). See https://github.com/koalaman/shellcheck/wiki/SC2115

        if [[ "$tmp_path/$queue" == "$audit_tmp_path/$queue" ]] ; then
            ( cd -- "${audit_tmp_path:?}" && /bin/rm -rf --one-file-system -- "${queue:?}" ; )
        fi

        if [[ "$tmp_path/$catalog" == "$audit_tmp_path/$catalog" ]] ; then
            ( cd -- "${audit_tmp_path:?}" && /bin/rm -rf --one-file-system -- "${catalog:?}" ; )
        fi

        if [[ "$tmp_path/$decompressed" == "$audit_tmp_path/$decompressed" ]] ; then
            ( cd -- "${audit_tmp_path:?}" && /bin/rm -rf --one-file-system -- "${decompressed:?}" ; )
        fi

        if [[ "$tmp_path/$parents" == "$audit_tmp_path/$parents" ]] ; then
            ( cd -- "${audit_tmp_path:?}" && /bin/rm -rf --one-file-system -- "${parents:?}" ; )
        fi

        if [[ "$tmp_path/$backtrack" == "$audit_tmp_path/$backtrack" ]] ; then
            ( cd -- "${audit_tmp_path:?}" && /bin/rm -rf --one-file-system -- "${backtrack:?}" ; )
        fi

        if [[ "$tmp_path/$detections" == "$audit_tmp_path/$detections" ]] ; then
            ( cd -- "${audit_tmp_path:?}" && /bin/rm -rf --one-file-system -- "${detections:?}" ; )
        fi

        # Note that $report is not deleted, because it contains output for the user.
    fi
}


is_zip() {
    # Returns exit code 0 if $file_to_check is a jar/zip file. Returns non-zero
    # exit code if it doesn't exist or is not a jar/zip file.
    #
    # Args:
    #     file_to_check
    #
    # Side effects:
    #     Exits, if $file_to_check is outside of allowed paths ($scan_path or
    #     $tmp_path).

    local file_to_check="$1"

    if [[ -f "$file_to_check" && ! -L "$file_to_check" ]] ; then
        validate_path_inside_scan_or_tmp "$( pwd )/$file_to_check"
        file -b -- "$file_to_check" | grep -q -E '^(Java archive data)|(Zip archive data)'
    else
        return 1
    fi
}


# Even though this is not correct general-purpose XML processing, it works for all known log4j-core version 2 releases.
is_log4j() {
    # Returns exit code 0 if $file_to_check is a log4j jar file. Returns non-zero
    # exit code if it doesn't exist or is not a log4j jar file.
    #
    # Args:
    #     file_to_check
    #
    # Side effects:
    #     Exits, if $file_to_check is outside of allowed paths ($scan_path or
    #     $tmp_path).

    local file_to_check="$1"

    local parent_il
    local pom_file
    if [[ -d "$file_to_check" && ! -L "$file_to_check" ]] ; then
        (
            cd -- "$file_to_check" && {
                # Forbid reading from anywhere else than inside scan_path or tmp_path
                validate_path_inside_scan_or_tmp "$( pwd )"

                # The ZIP file format allows the same file name to be stored multiple times.
                # An example of such a file in the wild is xmlbeans-2.6.0.jar (even though
                # irrelevant for CVE-2021-44228).
                # Therefore, theoretically, if there were multiple pom.xml files in the archive,
                # it would make sense to analyze all of them.
                # When duplicate filenames are present, unzip -B appends in sequence ~, ~1, ~2,
                # and so on. With extglob, optional number is *([0-9]), optional ~ is ?("~"), and
                # the whole optional appendix is then ?("~"*([0-9]))
                for pom_file in "$POM_PATH"?("~"*([0-9])) ; do
                    if [[ -f "$pom_file" && ! -L "$pom_file" ]] ; then
                        validate_path_tmp "$tmp_path/$decompressed" "$( pwd )/$pom_file"
                        parent_il="$( grep -A5 -F "<parent>" "$pom_file" | grep -B5 -F "</parent>" )"
                        if { echo "$parent_il" | grep -q -F '<groupId>org.apache.logging.log4j</groupId>' ; } ; then
                            if { echo "$parent_il" | grep -q -F '<artifactId>log4j</artifactId>' ; } ; then
                                return 0
                            fi
                        fi
                    fi
                done
            }
            return 1
        )
    fi
}


is_vulnerable() {
    # Returns exit code 0 if $file_to_check is a log4j jar file with version
    # 2.0-<2.15, except for 2.12.2. Returns non-zero exit code if it doesn't
    # exist or the answer is "no"
    #
    # Args:
    #     file_to_check
    #
    # Side effects:
    #     Exits, if $file_to_check is outside of allowed paths ($scan_path or
    #     $tmp_path).

    local file_to_check="$1"

    local parent_iv
    local version
    local minor
    local pom_file

    if [[ -d "$file_to_check" && ! -L "$file_to_check" ]] ; then
        (
            cd -- "$file_to_check" && {
                # Forbid reading from anywhere else than inside scan_path or tmp_path
                validate_path_inside_scan_or_tmp "$( pwd )"

                for pom_file in "$POM_PATH"?("~"*([0-9])) ; do
                    if [[ -f "$pom_file" && ! -L "$pom_file" ]] ; then
                        validate_path_tmp "$tmp_path/$decompressed" "$( pwd )/$pom_file"
                        parent_iv="$( grep -A5 -F "<parent>" "$pom_file" | grep -B5 -F "</parent>" )"
                        if { echo "$parent_iv" | grep -q -F '<groupId>org.apache.logging.log4j</groupId>' ; } ; then
                            if { echo "$parent_iv" | grep -q -F '<artifactId>log4j</artifactId>' ; } ; then
                                version="$( echo "$parent_iv" | grep -o -E '<version>2\..*</version>' | grep -o -E '2[^<]*' )"
                                if [[ "$version" == "" ]] ; then
                                    # Not vulnerable, because this is not version 2.
                                    return 1
                                fi
                                minor="${version##2.}"
                                minor="${minor%%-*}"
                                minor="${minor%%.*}"
                                if (( minor < 15 && minor >= 0 )) ; then
                                    # vulnerable to CVE-2021-44228 are versions between earliest 2.0 and lower than 2.15 (not including 2.15), except for 2.3.1, 2.3.2, 2.12.2, 2.12.3, 2.12.4
                                    # - https://logging.apache.org/log4j/2.x/security.html
                                    # - https://logging.apache.org/log4j/log4j-2.12.1/
                                    if [[ "$version" == "2.3.1" ]] ; then
                                        return 1
                                    elif [[ "$version" == "2.3.2" ]] ; then
                                        return 1
                                    elif [[ "$version" == "2.12.2" ]] ; then
                                        return 1
                                    elif [[ "$version" == "2.12.3" ]] ; then
                                        return 1
                                    elif [[ "$version" == "2.12.4" ]] ; then
                                        return 1
                                    else
                                        return 0
                                    fi
                                fi
                            fi
                        fi
                    fi
                done
            }
            return 1
        )
    fi
}


save_relationship() {
    # Saves information about a relationship of two files and the path fragment
    # that leads from one to the other. This information is saved under $tmp_path/$parents.
    #
    # Args:
    #     pch - parent content hash
    #     cch - child content hash
    #     pf  - path fragment (relative path of child under parent)
    #     hpf - hash of the path fragment
    #
    # Side effects:
    #     Exits, if using any of $pch, $cch or $hpf would result in a path
    #     outside of $tmp_path/$parents.

    local pch="$1"
    local cch="$2"
    local pf="$3"
    local hpf="$4"

    validate_path_tmp "$tmp_path/$parents" "$tmp_path/$parents/$cch"
    safe_mkdir_parents "$cch"

    validate_path_tmp "$tmp_path/$parents/$cch" "$tmp_path/$parents/$cch/$pch"
    safe_mkdir_parents "$cch/$pch"

    validate_path_tmp "$tmp_path/$parents/$cch/$pch" "$tmp_path/$parents/$cch/$pch/$hpf"
    validate_path_tmp "$tmp_path/$parents" "$tmp_path/$parents/$cch/$pch/$hpf"
    safe_echo_parents "$pf" "$cch/$pch/$hpf"
}


err_unreadable() {
    echo "Please make sure that contents of SCANPATH are readable."
    echo "An illustrative example how to solve this issue:"
    echo "  1. create a temporary copy of the scanned directory, such as"
    echo "     # sudo cp -R SCANPATH NEWCOPY"
    echo "  2. review that all files and directories were copied correctly"
    echo "  3. change permissions to allow all users to access the new copy, such as"
    echo "     # sudo chmod a+rwX -R NEWCOPY"
    echo "     or alternatively change the owner to your user and group, such as"

    # The intention here is NOT to expand the expressions.
    # shellcheck disable=SC2016
    echo '     # sudo chown "$( id -u )":"$( id -g )" -R NEWCOPY'

    echo "  4. review that all files and directories in NEWCOPY are now accessible"
    echo '  5. run the script again, with --scan "NEWCOPY"'
    echo
    echo "See the Managing file permissions chapter of the Red Hat Enterprise Linux 8 Guide for more information:"
    echo "https://access.redhat.com/documentation/en-us/red-hat-enterprise-linux/8/guide/dd67f6eb-c24b-41b1-97cd-7e2b9ad60355"
    echo
    echo "Exiting."
    print_debug
    exit 3
}


check_dir() {
    # Iterates over the specified $dir_to_catalog and tries to access regular files
    # and directories.
    #
    # Args:
    #     dir_to_check - dir to be checked
    #
    # Side effects:
    #     Exits, if $dir_to_check is outside of $scan_path or $tmp_path, or if
    #     any included file or directory is inaccessible.

    local dir_to_check="$1"
    local fn

    if [[ -d "$dir_to_check" && ! -L "$dir_to_check" ]] ; then
        (
            if cd -- "$dir_to_check" ; then
                # Forbid reading from anywhere else than inside scan_path or tmp_path
                if [[ "$dir_to_check" != "$scan_path" ]] ; then
                    validate_path_inside_scan_or_tmp "$( pwd )"
                fi

                # Skipping over symlinks just the same as catalog_dir and everything else skips over symlinks.

                for fn in * ; do
                    if [[ -f "$fn" && ! -L "$fn" ]] ; then
                        if [[ ! -r "$fn" ]] ; then
                            echo "Error: Cannot access file '$fn'"
                            echo "in '$( pwd )'"
                            echo
                            err_unreadable
                        fi
                    elif [[ -d "$fn" && ! -L "$fn" ]] ; then
                        check_dir "$dir_to_check/$fn"
                    fi
                done
            else
                echo "Error: Cannot change to directory '$dir_to_check'"
                echo "from '$( pwd )'"
                echo
                err_unreadable
            fi
        )
    else
        echo "Error: This is not a directory $dir_to_check"
        echo "in $( pwd )"
        echo
        err_unreadable
    fi
}


catalog_dir() {
    # Iterates over the specified $dir_to_catalog and processes regular files
    # (by calling catalog_file) and directories (recursively calling itself).
    # Passes $path_fragment and $parent_content_hash to the recursively-called
    # functions.
    #
    # Args:
    #     dir_to_catalog - dir to be cataloged
    #     path_fragment - path fragment from parent file
    #     parent_content_hash - hash of the parent file contents
    #
    # Side effects:
    #     Exits, if $dir_to_catalog is outside of $scan_path or $tmp_path.

    local dir_to_catalog="$1"
    local path_fragment="$2"
    local parent_content_hash="$3"
    local fn

    if [[ -d "$dir_to_catalog" && ! -L "$dir_to_catalog" ]] ; then
        (
            cd -- "$dir_to_catalog" && {
                # Forbid reading from anywhere else than inside scan_path or tmp_path
                if [[ "$dir_to_catalog" != "$scan_path" ]] ; then
                    validate_path_inside_scan_or_tmp "$( pwd )"
                fi

                for fn in * ; do
                    if [[ -f "$fn" && ! -L "$fn" ]] ; then
                        catalog_file "$fn" "$path_fragment/$fn" "$parent_content_hash"
                    elif [[ -d "$fn" && ! -L "$fn" ]] ; then
                        catalog_dir "$fn" "$path_fragment/$fn" "$parent_content_hash"
                    fi
                done
            }
        )
    fi
}


catalog_file() {
    # Briefly analyzes the file, decides whether to queue it for extraction,
    # finds already-processed duplicates, and records the file's relationship
    # information (parent, path fragment).
    #
    # Args:
    #     file_to_catalog - file to be cataloged
    #     path_fragment - path fragment from parent file
    #     parent_content_hash - hash of the parent file contents
    #
    # Side effects:
    #     Exits, if $file_to_catalog is outside of $scan_path or $tmp_path, or
    #     if unexpected things happen (reading/writing outside of approved
    #     paths or hashing not working as expected).

    local file_to_catalog="$1"
    local path_fragment="$2"
    local parent_content_hash="$3"

    local size
    local hash
    local path_fragment_hash

    # Forbid reading from anywhere else than inside scan_path or tmp_path
    validate_path_inside_scan_or_tmp "$( pwd )/$file_to_catalog"
    size="$( stat -c%s -- "$file_to_catalog" )"

    # smallest known log4j-core is 375010 bytes, smallest known non-alpha is 702665 bytes, so 300k leaves us with a cushion in case there are other builds out there
    if (( size > 300000 )) ; then
        if is_zip "$file_to_catalog" ; then

            if (( print_progress )) ; then
                # $queue_length might be out-of-date, but it's not an essential feature
                echo "[ $queue_position / $( get_queue_length ) ] Cataloging file ${file_to_catalog:0:60}..."
            fi

            hash="$( safe_sha256_sum_from_file "$( pwd )/$file_to_catalog" )"
            path_fragment_hash="$( safe_sha256_sum_from_string "$path_fragment" )"
            if [[ -f "$tmp_path/$catalog/$hash" ]] ; then
                # Already processed, so just record the new path
                # Args of save_relationship:
                # 1 - parent content hash
                # 2 - child content hash
                # 3 - path fragment from parent to child
                # 4 - hash of path fragment from parent to child
                save_relationship "$parent_content_hash" "$hash" "$path_fragment" "$path_fragment_hash"
            else
                # This is being run in a subshell, so we don't see current global variables, nor is there write access to them, but it's possible to update them, just for this subshell.
                queue_length="$( get_queue_length )"
                queue_length="$(( queue_length + 1 ))"
                safe_cp_queue "$( pwd )/$file_to_catalog" "q-${queue_length}-$hash"
                safe_touch_catalog "$hash"
                # Args of save_relationship:
                # 1 - parent content hash
                # 2 - child content hash
                # 3 - path fragment from parent to child
                # 4 - hash of path fragment from parent to child
                save_relationship "$parent_content_hash" "$hash" "$path_fragment" "$path_fragment_hash"
            fi
        fi
    fi
}


unpack_cataloged_recatalog() {
    # Processes queued files by extracting them and iterating over their
    # contents, adding new found files into the queue.
    # Detects affected log4j jar files among the queued files (even nested).
    #
    # Side effects:
    #   * Uses significant disk space, depending on the original contents of
    #     $scan_path, which was loaded into $tmp_path before this function is
    #     run.
    #   * Exits, if any file operation happens outside of $tmp_path, or if
    #     any path to be used is found to be non-canonical (e.g. containing
    #     symlinks). Exits if any of the operations do not pass their
    #     individual validations.

    local queued_path
    local cataloged_hash_ucr

    queue_length="$( get_queue_length )"
    while (( queue_position < queue_length )) ; do
        queue_position="$(( queue_position + 1 ))"
        queue_length="$( get_queue_length )"
        if (( queue_length_check <= queue_length )) ; then
            queue_length_check="$queue_length"
        else
            echo "An external modification occurred in $tmp_path/$queue"
            echo
            err_internal_path_validation
        fi

        for queued_path in "$tmp_path/$queue/q-$queue_position-"* ; do
            :
            # just using the for loop to resolve the glob
        done

        if [[ ! -f "$queued_path" ]] ; then
            continue
        fi

        validate_path_tmp "$tmp_path/$queue" "$queued_path"

        cataloged_hash_ucr="$( basename -- "$queued_path" )"
        cataloged_hash_ucr="${cataloged_hash_ucr#q-${queue_position}-}"
        if [[ "$queued_path" != "$tmp_path/$queue/q-$queue_position-$cataloged_hash_ucr" ]] ; then
            echo "An external modification occurred in $tmp_path/$queue"
            echo
            err_internal_path_validation
        fi

        validate_path_tmp "$tmp_path/$decompressed" "$tmp_path/$decompressed/$cataloged_hash_ucr"

        if [[ -d "$tmp_path/$decompressed/$cataloged_hash_ucr" ]] ; then
            # Already processed. This shouldn't happen, unless someone else adds new files here. Please, don't do that.
            :  #skip
        else

            if (( print_progress )) ; then
                echo "[ $queue_position / $queue_length ] Extracting file..."
            fi

            safe_mkdir_decompressed "$cataloged_hash_ucr" 
            (
                # * -qq keeps quiet
                # * -B creates backup files in case of file name collisions
                #     * therefore, both the original and the new versions exist in the output directory
                #     * it doesn't matter that the file name gets changed, because the script analyzes files based on file type based on contents, not based on filename
                # * -n forbids overwriting files during extraction
                # * -qqBn tested to preserve all unzipped files with xmlbeans-2.6.0.jar that is known to contain duplicate zip entries
                unzip -qqBn "$queued_path" -d "$tmp_path/$decompressed/$cataloged_hash_ucr" >/dev/null 2>&1  || true
            )
            
            if is_log4j "$tmp_path/$decompressed/$cataloged_hash_ucr" ; then
                if is_vulnerable "$tmp_path/$decompressed/$cataloged_hash_ucr" ; then
                    validate_path_tmp "$tmp_path/$detections" "$tmp_path/$detections/$cataloged_hash_ucr"
                    safe_touch_detections "$cataloged_hash_ucr"
                fi
            fi

            # Args of catalog_dir:
            # 1 - dir to be cataloged
            # 2 - path fragment from parent
            # 3 - parent content hash
            catalog_dir "$tmp_path/$decompressed/$cataloged_hash_ucr" "" "$cataloged_hash_ucr"

            safe_rm_rf_decompressed "$cataloged_hash_ucr"
        fi
    done
}


produce_report() {
    # Assembles recorded file relationships, path fragments, and log4j
    # detections into full paths of detected affected log4j jar files, and
    # saves these paths into .txt files in $tmp_path/$report.
    #
    # Side effects:
    #     Exits, if any file operation happens outside of $tmp_path, or if
    #     any path to be used is found to be non-canonical (e.g. containing
    #     symlinks). Exits if any of the operations do not pass their
    #     individual validations.

    local detection_note_pr
    local cataloged_hash_pr
    local immediate_parent_pr
    local immediate_parent_cataloged_hash_pr
    local immediate_parent_pathfragment_path_pr
    local immediate_parent_pathfragment_fn_pr
    local immediate_parent_pathfragment_pr
    local immediate_parent_pathfragment_hash_pr
    local parent_pr
    local parent_cataloged_hash_pr
    local grandparent_pr
    local grandparent_pathfragment_path_pr
    local parent_pathfragment_path_pr
    local detection_path_pr
    local grandparent_cataloged_hash_pr
    local grandparent_pathfragment_fn_pr
    local grandparent_pathfragment_pr
    local parent_pathfragment_fn_pr
    local parent_pathfragment_pr
    local assembled_grandparent_pathfragment_pr
    local assembled_grandparent_pathfragment_hash_pr
    local relevant_ls_pr
    local num_relevant_ls_pr
    local detection_path_basename_pr
    local report_filename_pr
    local detection_path_pathfragment_pr

    # Record all leaf file path fragments (like "/log4j.jar") and all the parents that include these vulnerable files
    for detection_note_pr in "$tmp_path/$detections"/* ; do
        cataloged_hash_pr="$( basename -- "$detection_note_pr" )"
        validate_path_tmp "$tmp_path/$detections" "$tmp_path/$detections/$cataloged_hash_pr"
        validate_path_tmp "$tmp_path/$parents" "$tmp_path/$parents/$cataloged_hash_pr"
        for immediate_parent_pr in "$tmp_path/$parents/$cataloged_hash_pr"/* ; do
            immediate_parent_cataloged_hash_pr="$( basename -- "$immediate_parent_pr" )"
            validate_path_tmp "$tmp_path/$parents/$cataloged_hash_pr" "$tmp_path/$parents/$cataloged_hash_pr/$immediate_parent_cataloged_hash_pr"
            validate_path_tmp "$tmp_path/$parents/$cataloged_hash_pr" "$immediate_parent_pr"
            for immediate_parent_pathfragment_path_pr in "$immediate_parent_pr"/* ; do
                validate_path_tmp "$tmp_path/$parents/$cataloged_hash_pr/$immediate_parent_cataloged_hash_pr" "$immediate_parent_pathfragment_path_pr"
                immediate_parent_pathfragment_fn_pr="$( basename -- "$immediate_parent_pathfragment_path_pr" )"
                validate_path_tmp "$tmp_path/$parents/$cataloged_hash_pr/$immediate_parent_cataloged_hash_pr" "$tmp_path/$parents/$cataloged_hash_pr/$immediate_parent_cataloged_hash_pr/$immediate_parent_pathfragment_fn_pr"
                immediate_parent_pathfragment_pr="$( safe_cat_parents "$cataloged_hash_pr/$immediate_parent_cataloged_hash_pr/$immediate_parent_pathfragment_fn_pr" )"
                immediate_parent_pathfragment_hash_pr="$( safe_sha256_sum_from_string "$immediate_parent_pathfragment_pr" )"
                validate_path_tmp "$tmp_path/$backtrack" "$tmp_path/$backtrack/$immediate_parent_cataloged_hash_pr"
                safe_mkdir_backtrack "$immediate_parent_cataloged_hash_pr"
                validate_path_tmp "$tmp_path/$backtrack/$immediate_parent_cataloged_hash_pr" "$tmp_path/$backtrack/$immediate_parent_cataloged_hash_pr/$immediate_parent_pathfragment_hash_pr"
                safe_echo_backtrack "$immediate_parent_pathfragment_pr" "$immediate_parent_cataloged_hash_pr/$immediate_parent_pathfragment_hash_pr"
            done
        done
    done

    relevant_ls_pr=( "$tmp_path/$backtrack"/!(0) )
    num_relevant_ls_pr="${#relevant_ls_pr[@]}"

    # Resolve the paths one layer at a time
    while (( num_relevant_ls_pr > 0 )) ; do
        # One of them should be "0" - the scan_path.
        # If there's sth else, it's yet-unresolved path fragments.
        for parent_pr in "$tmp_path/$backtrack"/* ; do
            parent_cataloged_hash_pr="$( basename -- "$parent_pr" )"
            if [[ "$parent_cataloged_hash_pr" == "0" ]] ; then
                continue
            fi
            for grandparent_pr in "$tmp_path/$parents/$parent_cataloged_hash_pr"/* ; do
                grandparent_cataloged_hash_pr="$( basename -- "$grandparent_pr" )"
                for grandparent_pathfragment_path_pr in "$grandparent_pr"/* ; do
                    validate_path_tmp "$tmp_path/$parents/$parent_cataloged_hash_pr/$grandparent_cataloged_hash_pr" "$grandparent_pathfragment_path_pr"
                    grandparent_pathfragment_fn_pr="$( basename -- "$grandparent_pathfragment_path_pr" )"
                    validate_path_tmp "$tmp_path/$parents/$parent_cataloged_hash_pr/$grandparent_cataloged_hash_pr" "$tmp_path/$parents/$parent_cataloged_hash_pr/$grandparent_cataloged_hash_pr/$grandparent_pathfragment_fn_pr"
                    grandparent_pathfragment_pr="$( safe_cat_parents "$parent_cataloged_hash_pr/$grandparent_cataloged_hash_pr/$grandparent_pathfragment_fn_pr" )"
                    for parent_pathfragment_path_pr in "$parent_pr"/* ; do
                        validate_path_tmp "$tmp_path/$backtrack" "$parent_pathfragment_path_pr"
                        parent_pathfragment_fn_pr="$( basename -- "$parent_pathfragment_path_pr" )"
                        validate_path_tmp "$tmp_path/$backtrack" "$tmp_path/$backtrack/$parent_cataloged_hash_pr/$parent_pathfragment_fn_pr"
                        parent_pathfragment_pr="$( safe_cat_backtrack "$parent_cataloged_hash_pr/$parent_pathfragment_fn_pr" )"
                        # Double slash to signify an archive (one of the slashes is already at the beginning of $parent_pathfragment_pr)
                        assembled_grandparent_pathfragment_pr="$grandparent_pathfragment_pr/$parent_pathfragment_pr"
                        assembled_grandparent_pathfragment_hash_pr="$( safe_sha256_sum_from_string "$assembled_grandparent_pathfragment_pr" )"
                        validate_path_tmp "$tmp_path/$backtrack" "$tmp_path/$backtrack/$grandparent_cataloged_hash_pr"
                        safe_mkdir_backtrack "$grandparent_cataloged_hash_pr"
                        validate_path_tmp "$tmp_path/$backtrack/$grandparent_cataloged_hash_pr" "$tmp_path/$backtrack/$grandparent_cataloged_hash_pr/$assembled_grandparent_pathfragment_hash_pr"
                        safe_echo_backtrack "$assembled_grandparent_pathfragment_pr" "$grandparent_cataloged_hash_pr/$assembled_grandparent_pathfragment_hash_pr"
                    done
                done
            done
            validate_path_tmp "$tmp_path/$backtrack" "$tmp_path/$backtrack/$parent_cataloged_hash_pr"
            safe_rm_rf_backtrack "$parent_cataloged_hash_pr"
        done

        relevant_ls_pr=( "$tmp_path/$backtrack"/!(0) )
        num_relevant_ls_pr="${#relevant_ls_pr[@]}"

    done

    # Copy and rename the files into "report"
    for detection_path_pr in "$tmp_path/$backtrack"/0/* ; do
        detection_path_basename_pr="$( basename -- "$detection_path_pr" )"
        report_filename_pr="vuln_log4j2_path_${detection_path_basename_pr:0:16}.txt"
        validate_path_tmp "$tmp_path/$backtrack" "$detection_path_pr"
        validate_path_tmp "$tmp_path/$backtrack" "$tmp_path/$backtrack/0/$detection_path_basename_pr"
        detection_path_pathfragment_pr="$( safe_cat_backtrack "0/$detection_path_basename_pr" )"
        validate_path_tmp "$tmp_path/$report" "$tmp_path/$report/$report_filename_pr"
        safe_echo_report "${scan_path}${detection_path_pathfragment_pr}" "$report_filename_pr"
        vulnerable="$(( vulnerable + 1 ))"
    done

    if (( vulnerable )); then
        result=2
    fi
}


if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    set_default_values
    if [[ "$#" == "0" ]] ; then
        # A sufficiently old Bash (such as in RHEL6) treats "$@" as an error if 'set -ue' and $#==0.
        basic_args --help
    else
        basic_args "$@"
    fi
    basic_reqs "CVE-2021-44228"

    # This variable is referenced indirectly, and this warning is marked to produce a false positive in that scenario.
    # shellcheck disable=SC2034
    running_kernel=$( uname -r )

    prepare_directories

    if (( print_progress )) ; then
        echo "[ ? / ? ] Inspecting ${scan_path}..."
        echo "[ ? / ? ] This might take considerable time..."
    fi

    check_dir "$scan_path"

    # Args of catalog_dir:
    # 1 - dir to be cataloged
    # 2 - path fragment from parent
    # 3 - parent content hash
    catalog_dir "$scan_path" "" "0"

    while [[ "$num_before" != "$num_after" ]] ; do
        num_before="$num_after"
        unpack_cataloged_recatalog
        catalog_files_for_counting_num=( "$tmp_path/$catalog"/* )
        num_after=${#catalog_files_for_counting_num[@]}
    done

    produce_report

    delete_directories

    echo "Finished scanning of the specified directory"
    echo "$scan_path"
    echo

    if (( vulnerable )); then
        echo -e "${RED}The specified directory ${BOLD}contains vulnerable${RESET}${RED} log4j-core jar files.${RESET}"
        echo "* $vulnerable files were identified."
        echo "* Paths of the identified files can be found in .txt files in the directory"
        echo "  $tmp_path/$report"
        echo "* To print all these paths, you can run the following command in the 'report' directory:" 
        echo "  cat vuln_log4j2_path_*.txt"
        echo "* The paths may show paths inside zip/jar archive files, signified by a double slash //."

    else
        echo -e "${GREEN}The specified directory ${BOLD}does not${RESET}${GREEN} contain vulnerable log4j-core jar files.${RESET}"
    fi

    echo
    echo "Please note that vulnerability is determined based on the version only."
    echo "This script doesn't detect any mitigations."
    echo
    echo -e "Follow $BULLETIN for advice."

    print_debug

    exit "$result"
fi
